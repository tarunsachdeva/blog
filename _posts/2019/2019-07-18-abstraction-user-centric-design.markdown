---
layout: post
title:  "Abstraction and User Centric Design"
comments: true
date:   2019-07-18 12:00:00 -0500
categories: general
draft: false
---

This post is a set of disconnected thoughts about abstraction - arguably the most important mental model in software design.

> In the computer science and software engineering domain, the abstraction principle is used to reduce complexity and allow efficient design and implementation of complex software systems.

> The process of abstraction can also be referred to as modeling and is closely related to the concepts of theory and design. Models can also be considered types of abstractions per their generalization of aspects of reality.

> Computer science commonly presents levels (or, less commonly, layers) of abstraction, wherein each level represents a different model of the same information and processes, but with varying amounts of detail.

I've previously talked about how software is _modelling_ the world (_eating it_ sounds off - I get it, but still). When things move into the domain of software â€“ a domain of almost infinite flexibility - interesting new dynamics emerge that then alter the real world itself. A good example of this is how social media is changing some fundamental dynamics of the "real world". 

Abstraction removes complexity that allows for technology to become more accessible. This is particularly true in software development, where innovations in abstractions made development more approachable by those less technically inclined. Early web and mobile development abstracted the details of devices which invited more developers and creating the grounds for more innovation. Services like Glitch abstracted the complexity of building a full fledged web app with some intelligent defaults and easy to use interface. AWS, Heroku and Firebase continue to abstract infrastructure to the point where spinning up a web server is a few clicks of work. In all these examples, abstraction is what creates inclusivity and spurs innovation. 